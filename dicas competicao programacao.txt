Complexidade de Tempo: O(n). O loop percorre a lista de n elementos uma única vez, então o tempo de execução é linear em relação ao tamanho da entrada.

Complexidade de Espaço: O(1). A solução usa apenas uma variável para armazenar o resultado (single), independentemente do tamanho da lista. Isso significa que o espaço extra necessário é constante.

input() retorna uma string

% resto
// divisao inteira

Ler eof
while True:
    try:
        linha = input()
        if linha == "": 
            break
        t = int(linha)
    except (EOFError, ValueError):
        break

Ler linha de valores com delimitador espaço
h, z, l = map(int, input().split())

import re

texto = "3+8=J"
resultado = re.split(r'[+=]', texto)

print(" ".join(res)) não coloca espaço no começo nem no final.
print(l[i],end="") -- nao pular linha
print(f"{frase:>{largura}}")
print(f"{5:.5f}")

alfabeto = {chr(i): 0 for i in range(97, 123)}
alfabeto.values()
alfabeto.items()
list(idiomas.keys())[0]

max(vetor, key=len)

Qualquer número XOR 0 é o próprio número. Por exemplo: a ^ 0 = a.
Qualquer número XOR ele mesmo é 0. Por exemplo: a ^ a = 0.
n & (n-1) é potencia de 2

Wrap-around é essencial para reutilizar espaços

Cifra de César
nova_letra = chr((ord(letra) - base + deslocamento) % 26 + base)
decifrar de César
nova_letra = chr((ord(letra) - base - deslocamento) % 26 + base)


conjunto1 = {1, 2, 3}

# Usando set() - útil para converter listas sem repetição
conjunto2 = set([1, 2, 2, 3, 3])  # Resultado: {1, 2, 3}

# Conjunto vazio (não pode usar {} pois cria dicionário)
conjunto_vazio = set()
a.add(5)
a.remove(3)

transformar numero para binario format(n,'b') f'{n:b}'

inicial lista com tamanho
inicial = [0] * len(target)


Linked List

from typing import List, Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
		
def create_linked_list(lst: List[int]) -> Optional[ListNode]:
    if not lst:
        return None
    head = ListNode(lst[0])
    current = head
    for val in lst[1:]:
        current.next = ListNode(val)
        current = current.next
    return head

def linked_list_to_list(head: Optional[ListNode]) -> List[int]:
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result
	
Inicializa Matriz
grid = [[0] * n for _ in range(m)]

implementa filas de prioridade 
import heapq 
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 2)
heapq.heappush(heap, 8)
heapq.heappush(heap, 1)
print(heap)

menor = heapq.heappop(heap)